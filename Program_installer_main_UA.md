# Автоматизований засіб встановлення програм для Windows

![Desktop Organizer Screenshot](Program_install_2.PNG)


## Огляд

Автоматизований засіб встановлення програм – це утиліта на базі Python, розроблена для оптимізації процесу виявлення, встановлення та керування програмним забезпеченням у системах **Windows**, з особливим акцентом на інженерні програми. Вона має графічний інтерфейс користувача (ГІК), створений за допомогою **`PyQt5`**, для зручності використання та використовує конфігураційні файли для ідентифікації конкретних інсталяторів, перевірки передумов або наявних встановлень через **Реєстр Windows** та виконання встановлень за допомогою тихих або напівавтоматичних ключів командного рядка. Інструмент також веде журнал успішних встановлень для полегшення автоматизованого видалення.

Цей інструмент насамперед призначений для ІТ-адміністраторів, досвідчених користувачів або інженерних команд, яким потрібно керувати розгортанням специфічних пакетів програмного забезпечення на багатьох машинах або забезпечувати узгоджені налаштування.

## Ключові можливості

*   **Графічний інтерфейс користувача:** Інтуїтивно зрозумілий та чутливий ГІК, побудований на **`PyQt5`**.
*   **Конфігуровані визначення програм:** Визначення відомих програм, їхніх ідентифікаційних характеристик (метадані, шаблони імен файлів), методів перевірки в реєстрі та команд тихого встановлення через центральну конфігурацію Python (**`PROGRAM_CONFIG`**).
*   **Автоматизоване виявлення інсталяторів:** Рекурсивно сканує вказані каталоги на наявність файлів **`.exe`** та **`.msi`**, застосовуючи конфігуровані фільтри для виключення нерелевантних файлів (наприклад, залежностей, деінсталяторів, малих файлів).
*   **Інтелектуальна ідентифікація:**
    *   Зіставляє інсталятори з **`PROGRAM_CONFIG`**, використовуючи метадані файлів (Назва продукту, Опис, Версія, витягнуті за допомогою **`pywin32`** та **`msilib`**) та шаблони імен файлів.
    *   Включає евристичний аналіз для ідентифікації потенційних інсталяторів, не налаштованих явно, на основі властивостей та умов іменування.
*   **Перевірка статусу встановлення:** Звертається до **Реєстру Windows** (переважно **`HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall`** та відповідних ключів **`HKCU`**) на основі налаштованих правил для визначення, чи встановлено програмне забезпечення, та отримання його версії.
*   **Гнучкі режими встановлення:**
    *   **"Авто (Тихе)":** Спроба встановлення без участі користувача з використанням попередньо визначених тихих ключів.
    *   **"Напівавтоматичне":** Виконує встановлення з мінімальним інтерфейсом користувача (наприклад, лише індикатор прогресу), використовуючи пасивні ключі.
    *   **"Вручну (Інтерактивне)":** Запускає стандартний ГІК інсталятора для взаємодії з користувачем.
*   **Ведення журналу встановлень:** Записує деталі встановлень, виконаних ***цим інструментом*** (ідентифікатор програми, назва, часова мітка, шлях до інсталятора, виявлена команда видалення/**`ProductCode`**, версія) у постійний файл журналу **`JSON`** (**`%APPDATA%\ProgramInstallerApp\program_installer_log.json`**).
*   **Автоматизоване видалення:** Використовує журнал встановлень для спроби тихого видалення раніше встановлених програм, використовуючи або записаний **`UninstallString`**, або MSI **`ProductCode`**.
*   **Покращення ГІК:** Включає фільтрацію, сортування, кольорове кодування стану, індикатори прогресу та відображення детальної інформації.
*   **Збереження стану:** Запам'ятовує останній використаний шлях сканування та геометрію вікна.
*   **Керування залежностями:** Перевіряє наявність необхідних бібліотек Python (**`PyQt5`**, **`pywin32`**) під час запуску.
*   **Фонова обробка:** Використовує **`QThread`** для неблокуючих операцій сканування, перевірки стану та встановлення/видалення, підтримуючи чутливість ГІК.

## Передумови

*   **Операційна система:** **Windows** (розроблено та протестовано на **Windows 10/11**). Потрібен доступ до **Windows API** та **Реєстру**.
*   **Python:** **Python 3.7** або новіша версія.
*   **Пакети Python:**
    *   **`PyQt5`**: Для графічного інтерфейсу користувача.
    *   **`pywin32`**: Для доступу до нативних **Windows API** (метадані файлів, доступ до реєстру, властивості MSI, керування процесами).

## Встановлення (Залежності)

Переконайтеся, що **`Python 3.7+`** встановлено та доступний з вашого командного рядка або середовища. Встановіть необхідні пакети Python за допомогою **`pip`**:

```bash
pip install PyQt5 pywin32
```

Рекомендується використовувати віртуальне середовище Python для керування залежностями.

## Конфігурація

**Дуже важливо: цей інструмент потребує конфігурації для розпізнавання та керування вашим специфічним програмним забезпеченням.**

1.  **Словник `PROGRAM_CONFIG` (Обов'язкове налаштування):**
    *   Знаходиться у скрипті **`install_programs.py`**.
    *   Цей словник є ядром бази знань інструменту. Кожен ключ представляє унікальний ідентифікатор програмного забезпечення (наприклад, **`"autocad_2024"`**).
    *   Пов'язане значення — це словник, що визначає:
        *   **`display_name`**: Зручна для користувача назва, що відображається в ГІК.
        *   **`target_version`**: (Необов'язково, наразі інформаційно) наприклад, **`"2024.1"`** або **`"latest"`**.
        *   **`identity`**: Критерії для ідентифікації файлу інсталятора:
            *   **`expected_product_names`**: Список можливих значень метаданих **`"ProductName"`**.
            *   **`expected_descriptions`**: Список можливих значень метаданих **`"FileDescription"`**.
            *   **`installer_patterns`**: Список шаблонів імен файлів у стилі **`fnmatch`** (наприклад, **`ACAD_2024*.exe`**).
        *   **`check_method`**: Правила для перевірки, чи встановлена програма, через реєстр:
            *   **`type`**: Наразі підтримується лише **`"registry"`**.
            *   **`keys`**: Список правил перевірки реєстру (словники), що вказують **`path`** (шлях), **`hive`** (**`HKLM`**/**`HKCU`**), **`match_value`** (значення для зіставлення, напр., **`DisplayName`**), **`match_pattern`** (регулярний вираз), **`get_value`** (значення для отримання, напр., **`DisplayVersion`**) або **`check_existence`** (просто перевірити існування шляху).
        *   **`install_commands`**: Шаблони командного рядка для різних режимів встановлення:
            *   Ключі: **`.exe`** або **`.msi`**.
            *   Значення: Рядки команд, що використовують **`{installer_path}`** (буде взято в лапки) та відповідні тихі (**`/S`**, **`/qn`**, **`/quiet`**), пасивні (**`/passive`**) або інші ключі. **Пошук правильних ключів часто вимагає звернення до документації постачальника або експериментів (наприклад, запуск `installer.exe /?`).**

    *   **Необхідні дії:** Ви ***повинні*** заповнити **`PROGRAM_CONFIG`** точними даними, що відповідають конкретним інсталяторам програмного забезпечення, якими ви збираєтеся керувати. Приклади записів є ілюстративними.

2.  **Словник `DETECTION_SETTINGS` (Необов'язкове налаштування):**
    *   Знаходиться у скрипті **`install_programs.py`**.
    *   Дозволяє точно налаштувати початковий процес сканування та евристичного виявлення:
        *   **`exclude_generic_names`**: Фільтрує загальні назви залежностей (наприклад, **`'driver'`**, **`'redist'`**).
        *   **`exclude_by_property_substrings`**: Фільтрує на основі підрядків у метаданих файлів (наприклад, **`'.net framework'`**, **`'visual c++'`**).
        *   **`exclude_uninstaller_hints`**: Фільтрує файли, які, ймовірно, є деінсталяторами (наприклад, **`'uninstall'`**, **`'remove'`**).
        *   **`min_file_size_bytes`**: Ігнорує файли, менші за цей поріг.
        *   **`ignore_dirs`**: Пропускає вказані назви каталогів під час сканування (наприклад, **`'backup'`**, **`'docs'`**, **`'temp'`**).

## Посібник з використання

1.  **Налаштуйте:** Відредагуйте словники **`PROGRAM_CONFIG`** та, за бажанням, **`DETECTION_SETTINGS`** у скрипті, як описано вище.
2.  **Запустіть:** Запустіть скрипт із вашого терміналу. **Примітка:** Встановлення та видалення зазвичай вимагають прав адміністратора. Розгляньте можливість запуску скрипту від імені адміністратора ("Запуск від імені адміністратора").
    ```bash
    python install_programs.py
    ```
3.  **Встановіть шлях сканування:** Натисніть кнопку **"Встановити шлях сканування..."** (іконка папки) на панелі інструментів. Перейдіть до кореневого каталогу, що містить інсталятори програмного забезпечення, та виберіть його. Сканування буде рекурсивним, з урахуванням **`ignore_dirs`**.
4.  **Скануйте інсталятори:** Натисніть кнопку **"Сканувати"** (іконка лупи). Додаток виконає пошук за вказаним шляхом, ідентифікує інсталятори на основі конфігурації та евристики та заповнить основний список.
5.  **Перевірте статус встановлення:** Натисніть кнопку **"Перевірити статус"** (іконка контрольного списку). Інструмент звернеться до Реєстру Windows для кожної налаштованої програми, щоб визначити її статус встановлення та версію.
6.  **Перегляньте результати:**
    *   Центральна таблиця відображає ідентифіковані програми, їхній статус (**"Встановлено"**, **"Версія"**, **"Інсталятор знайдено"**) та шлях до виявленого інсталятора.
    *   Кольорове кодування вказує на статус: Зелений (Встановлено), Синій (Інсталятор знайдено, не встановлено), Жовтий (Евристичне співпадіння), Білий/Сірий (Налаштовано, Інсталятор не знайдено/Не встановлено).
    *   Виберіть елемент, щоб переглянути детальну інформацію про властивості файлу та конфігураційні дані на нижній панелі.
    *   Використовуйте текстове поле **"Фільтр"** для динамічного пошуку у списку. Клацніть заголовки стовпців для сортування.
7.  **Виконайте дії:**
    *   Виберіть один або кілька записів програм у списку.
    *   Виберіть бажаний режим встановлення (**"Авто"**, **"Напівавтоматичне"**, **"Вручну"**) з випадаючого меню.
    *   Натисніть **"Встановити вибране"**: Ініціює встановлення для вибраних програм, для яких знайдено інсталятор і які наразі не позначені як встановлені. Вимагає прав адміністратора для більшості програмного забезпечення.
    *   Натисніть **"Видалити вибране"**: Спроба тихого видалення для вибраних *налаштованих* програм, які були раніше встановлені ***цим інструментом*** (і, отже, занесені до журналу). Це залежить від записаної інформації для видалення. Видалення евристично визначених елементів не підтримується.
8.  **Моніторинг прогресу:** Спостерігайте за рядком стану внизу для оновлень у реальному часі щодо поточних операцій (сканування, перевірка, встановлення). Перевіряйте вивід у консоль або файл журналу програми (**`%APPDATA%\ProgramInstallerApp\program_installer.log`**) для детальних повідомлень та можливих помилок.

## Як це працює (Технічний огляд)

*   **Сканування:** **`os.walk`** проходить по структурі цільового каталогу, фільтруючи на основі **`DETECTION_SETTINGS`** та розширень файлів (**`.exe`**, **`.msi`**).
*   **Ідентифікація:**
    *   **Вилучення метаданих:** Використовує **`win32api.GetFileVersionInfo`** (EXE) та **`msilib`** (MSI через **`COM`**) для читання властивостей, таких як **`ProductName`**, **`FileDescription`**, **`ProductVersion`** та **`ProductCode`**.
    *   **Фільтрація:** Застосовує додаткові фільтри на основі **`DETECTION_SETTINGS`**.
    *   **Зіставлення:** Порівнює вилучені метадані та імена файлів з правилами, визначеними в **`PROGRAM_CONFIG`**.
    *   **Евристика:** Оцінює неідентифіковані файли на основі розміру, іменування та наявності метаданих, щоб позначити потенційні інсталятори.
*   **Перевірка реєстру:** Використовує модуль **`winreg`** для навігації по гілках реєстру (**`HKLM`**, **`HKCU`**) та запиту ключів/значень відповідно до правил **`PROGRAM_CONFIG`**.
*   **Виконання:** Використовує **`subprocess.run`** (часто з **`start /wait ""`**) для запуску процесів інсталятора/деінсталятора з відповідними аргументами командного рядка на основі вибраного режиму та конфігурації. Моніторить коди виходу процесу (**`0`**, **`3010`**, **`1641`** зазвичай вказують на успіх/потребу перезавантаження). Для дій з MSI використовує Windows Installer **`COM API`** (**`msilib`**) для перевірки статусу встановлення/видалення через **`ProductCode`**, коли він доступний.
*   **Ведення журналу:** Використовує стандартний модуль **`logging`** Python для діагностики під час виконання. Зберігає записи про встановлення (ключ, назва, часова мітка, шляхи, команда видалення/**`ProductCode`**, версія) у файл **`JSON`** у каталозі **`%APPDATA%`** користувача для цілей видалення.

## Ведення журналу встановлень

Ключовим аспектом для видалення є файл журналу: **`%APPDATA%\ProgramInstallerApp\program_installer_log.json`**. Коли цей інструмент успішно завершує встановлення, він записує:

*   Використаний ключ **`PROGRAM_CONFIG`**.
*   Відображувану назву програми.
*   Часову мітку встановлення.
*   Повний шлях до використаного файлу інсталятора.
*   Виявлений **`UninstallString`** з реєстру ***після*** встановлення, АБО MSI **`ProductCode`**.
*   Виявлений рядок версії.

Функція **"Видалити вибране"** повністю залежить від цієї записаної інформації.

## Вирішення проблем

*   **Помилка встановлення:**
    *   Перевірте, чи правильні тихі ключі в **`PROGRAM_CONFIG`** для конкретної версії інсталятора. Зверніться до документації постачальника.
    *   Переконайтеся, що скрипт запущено з правами адміністратора.
    *   Перевірте вивід у консоль та **`program_installer.log`** на наявність повідомлень про помилки від інсталятора.
    *   Переконайтеся, що все необхідне попереднє програмне забезпечення або середовища виконання встановлені.
*   **Помилка видалення:**
    *   Видалення надійно працює лише для програм, встановлених ***цим інструментом***, для яких було успішно записано рядок видалення або **`ProductCode`**.
    *   Записана команда видалення може вимагати тихих ключів, які не додаються автоматично; може знадобитися ручне втручання.
    *   Переконайтеся у наявності прав адміністратора.
*   **Програма неправильно виявлена:**
    *   Уточніть правила **`identity`** (назви продуктів, описи, шаблони) в **`PROGRAM_CONFIG`**, щоб вони точно відповідали метаданим інсталятора. Використовуйте панель деталей у ГІК для перегляду метаданих, прочитаних з файлу.
    *   Налаштуйте **`DETECTION_SETTINGS`**, якщо дійсні інсталятори відфільтровуються (наприклад, збільште **`min_file_size_bytes`**, видаліть конфліктуючі рядки виключення).
*   **Неправильна перевірка реєстру:**
    *   Перевірте правильність шляхів реєстру **`check_method`**, імен значень та шаблонів у **`PROGRAM_CONFIG`**. Використовуйте **`regedit.exe`** для ручного огляду реєстру. Не забувайте перевіряти як **`HKLM`**, так і **`HKCU`** у **`SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall`** (а також потенційно специфічні ключі постачальника).

## Обмеження та міркування

*   **Точність тихих ключів:** Ефективність режимів **"Авто"** та **"Напівавтоматичне"** повністю залежить від знаходження та налаштування правильних ключів командного рядка для кожного конкретного інсталятора. Це часто вимагає дослідження або експериментів.
*   **Складні інсталятори:** Інсталятори, що включають кілька етапів, перевірки передумов, перезавантаження в процесі або інтерактивні запити на конфігурацію, можуть бути не повністю автоматизовані за допомогою простих тихих ключів.
*   **Права адміністратора:** Більшість операцій встановлення/видалення програмного забезпечення вимагають підвищених привілеїв. Скрипт потрібно запускати від імені адміністратора для цих операцій.
*   **Надійність евристики:** Евристичне виявлення (**`[Unk]`**/**`[SuS]`**) є недосконалим і може неправильно ідентифікувати файли або не виявити дійсні інсталятори. Завжди перевіряйте евристичні збіги вручну перед спробою встановлення.
*   **Обсяг видалення:** Автоматизоване видалення насамперед націлене на програмне забезпечення, встановлене ***за допомогою цього інструменту***. Хоча перевірки реєстру можуть ідентифікувати інші встановлення, їх видалення не гарантується або безпосередньо не підтримується без записаної інформації. Надійність деінсталятора залежить від якості деінсталятора постачальника та точності записаного **`UninstallString`** або **`ProductCode`**.
*   **Обробка помилок:** Хоча базова обробка помилок присутня, складні помилки, що генеруються ***всередині*** складних інсталяторів, можуть бути не перехоплені або чітко повідомлені цим інструментом. Зверніться до специфічних журналів інсталятора, якщо вони доступні.

## Ліцензія

Поширюється за ліцензією **`MIT`**. Дивіться файл **`LICENSE`**